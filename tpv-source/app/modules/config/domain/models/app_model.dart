// To parse this JSON data, do
//
//     final userModel = userModelFromJson(jsonString);

// ignore_for_file: overridden_fields, empty_catches

import 'dart:async';
import 'dart:convert';

import '../../../../../app/core/interfaces/entity_model.dart';
import '../../../../../app/core/services/logger_service.dart';
import '../../../../../globlal_constants.dart';
import '../entities/app.dart';

AppList appListModelFromJson(String str) => AppList.fromJson(json.decode(str));

AppModel appModelFromJson(String str) => AppModel.fromJson(json.decode(str));

String appModelToJson(AppModel data) => json.encode(data.toJson());

class AppList<T extends AppModel> implements EntityModelList<T> {
  final List<T> apps;

  AppList({
    required this.apps,
  });

  factory AppList.fromJson(Map<String, dynamic> json) => AppList(
        apps: json.containsKey("apps")
            ? List<T>.from(json["apps"].map((x) => AppModel.fromJson(x)))
            : [],
      );

  factory AppList.fromStringJson(String strJson) => AppList(
        apps: List<T>.from(
            json.decode(strJson)["apps"].map((x) => AppModel.fromJson(x))),
      );

  @override
  int get getTotal => getList().length;

  @override
  EntityModelList<T> add(T element) => fromList([element]);

  @override
  EntityModelList<T> fromJson(Map<String, dynamic> json) {
    return AppList.fromJson(json);
  }

  @override
  EntityModelList<T> fromList(List<T> list) {
    for (var element in list) {
      if (!apps.contains(element)) apps.add(element);
    }
    return this;
  }

  @override
  EntityModelList<T> fromStringJson(String strJson) {
    return AppList.fromStringJson(strJson);
  }

  @override
  List<T> getList() => apps;

  Map<String, dynamic> toJson() => {
        "apps": List<dynamic>.from(apps.map((x) => x.toJson())),
      };
}

class AppModel extends App implements EntityModel {
  @override
  final String applicationId;

  @override
  final String name;

  @override
  final String clientId;

  @override
  final String versionApk;
  @override
  final String logo;
  @override
  final String domain;
  @override
  Map<String, ColumnMetaModel>? metaModel;
  AppModel({
    required this.applicationId,
    required this.name,
    required this.clientId,
    required this.domain,
    required this.versionApk,
    required this.logo,
  }) : super(
          applicationId: applicationId,
          name: name,
          clientId: clientId,
          domain: domain,
          versionApk: versionApk,
          logo: logo,
        );
  factory AppModel.fromEmpty() => AppModel(
        applicationId: globalApplicationId,
        name: "Desconocida",
        clientId: "Sin id de cliente",
        domain: "enzona.net",
        versionApk: "0.0.0",
        logo: "Sin logo",
      );
  factory AppModel.fromJson(Map<String, dynamic> json) => AppModel(
        applicationId: getValueFrom("applicationId", json, globalApplicationId),
        name: getValueFrom("name", json, "Apk sin nombre"),
        clientId: getValueFrom("clientId", json, "Apk sin Id de cliente"),
        domain: getValueFrom("domain", json, "Apk sin dominio"),
        versionApk: getValueFrom("versionApk", json, "Apk sin versi칩n"),
        logo: getValueFrom("logo", json, "Apk sin Id de cliente"),
      );

  @override
  Map<String, ColumnMetaModel>? get getMetaModel => getColumnMetaModel();

  List<Object?> get props => [];
  @override
  set setMetaModel(Map<String, ColumnMetaModel> newMetaModel) {
    metaModel = newMetaModel;
  }

  bool? get stringify => true;

  //method generated by wizard

  T cloneWith<T extends EntityModel>(T other) {
    return AppModel.fromJson(other.toJson()) as T;
  }

  @override
  EntityModelList createModelListFrom(dynamic data) {
    try {
      if (data is Map) {
        return AppList.fromJson(data as Map<String, dynamic>);
      }
      if (data is String) {
        return AppList.fromStringJson(data);
      }
    } on Exception {
      log("Error al mapear el par치metro 'data'. Debe ser de tipo'Map<String, dynamic>' o String");
    }
    return AppList.fromJson({});
  }

  T fromJson<T extends EntityModel>(Map<String, dynamic> params) {
    return AppModel.fromJson(params) as T;
  }

  @override
  Map<String, ColumnMetaModel> getColumnMetaModel() {
    // TODO: implement getColumnMetaModel
    throw UnimplementedError();
  }

  @override
  Map<String, String> getColumnNames() {
    return {
      "applicationId": "Id de Aplicaci칩n",
      "name": "Nombre",
      "clientId": "Id cliente",
      "domain": "Dominio",
      "versionApk": "Versi칩n APK",
      "logo": "Logo",
    };
  }

  @override
  List<String> getColumnNamesList() {
    return getColumnNames().values.toList();
  }

  StreamController<EntityModel> getController({
    void Function()? onListen,
    void Function()? onPause,
    void Function()? onResume,
    FutureOr<void> Function()? onCancel,
  }) {
    return EntityModel.getController(
      entity: this,
      onListen: onListen,
      onPause: onPause,
      onResume: onResume,
      onCancel: onCancel,
    );
  }

  @override
  Map<K1, V1> getMeta<K1, V1>(String searchKey, dynamic searchValue) {
    final Map<K1, V1> result = {};
    getColumnMetaModel().map<K1, V1>((key, value) {
      MapEntry<K1, V1> el = MapEntry(value.getDataIndex() as K1, value as V1);
      if (value[searchKey] == searchValue) {
        result.putIfAbsent(value.getDataIndex() as K1, () {
          return value as V1;
        });
      }
      return el;
    });
    return result;
  }

  @override
  Map<String, String> getVisibleColumnNames() {
    // TODO: implement getVisibleColumnNames
    throw UnimplementedError();
  }

  @override
  Map<String, dynamic> toJson() => {
        "applicationId": applicationId,
        "name": name,
        "clientId": clientId,
        "domain": domain,
        "versionApk": versionApk,
        "logo": logo,
      };

  @override
  Map<String, ColumnMetaModel> updateColumnMetaModel(
      String keySearch, dynamic valueSearch, dynamic newValue) {
    Map<String, ColumnMetaModel> tmp = getColumnMetaModel();
    getMeta<String, ColumnMetaModel>(keySearch, valueSearch)
        .map<String, ColumnMetaModel>((key, value) {
      tmp.putIfAbsent(key, () => value);
      return MapEntry(key, value);
    });
    return metaModel = tmp;
  }

  static T getValueFrom<T>(
    String key,
    Map<dynamic, dynamic> json,
    T defaultValue, {
    JsonReader<T>? reader,
  }) {
    return EntityModel.getValueFromJson<T>(
      key,
      json,
      defaultValue,
      reader: reader,
    );
  }
}
